# Audio Output Refactor Plan: PWM to I2S DAC

## Overview

This document outlines the plan to replace the current PWM audio output with an I2S DAC (GY PCM5102 purple breakout board) while maintaining the interrupt-driven architecture and 8-bit internal processing.

## Hardware Changes

### New GPIO Routing
| Signal | GPIO | Description |
|--------|------|-------------|
| BCK (Bit Clock) | 18 | I2S bit clock output |
| DIN (Data) | 19 | I2S data output |
| LCK (Word Select) | 20 | I2S left/right channel select |

**Note**: GPIO 20 moves from PWM audio output to I2S LCK

### PCM5102 Breakout Configuration
- **SCK**: Leave unconnected (internal PLL mode)
- **FMT**: Tie to GND (I2S format)
- **FLT**: Tie to GND (normal filter latency)
- **DEMP**: Tie to GND (de-emphasis off)
- **XSMT**: Tie to VCC (soft mute disabled)
- **VCC**: 3.3V from Pico
- **GND**: Common ground

---

## Architecture Overview

### Current (PWM-based)
```
PWM Wrap Interrupt (31kHz)
    ↓
pwm_interrupt_handler()
    ↓
Audio Processing (8-bit)
    ↓
pwm_set_gpio_level(AUDIO_PIN, audio_now)
```

### New (I2S-based)
```
Timer Interrupt (31kHz)
    ↓
audio_interrupt_handler()  [renamed, same logic]
    ↓
Audio Processing (8-bit, unchanged)
    ↓
i2s_output_sample(audio_now)
    ↓
PIO FIFO → I2S Hardware
```

**Key Principle**: Keep all audio processing logic identical, only change the timing source and output method.

---

## Implementation Phases

## Phase 1: Create I2S PIO Module

### 1.1 Create `doth/i2s_audio.pio`

PIO program to generate I2S protocol:
- Generates BCK at 32x sample rate (for 16-bit stereo at 31kHz → 992kHz BCK)
- Outputs 16-bit left channel, then 16-bit right channel
- Toggles LCK (word select) between left/right

**PIO State Machine Configuration**:
- Clock divider: Set for 992kHz BCK (sys_clock / 992000)
- Side-set: 2 pins (BCK and LCK)
- OUT: DIN pin
- 32 bits per sample (16 left + 16 right, mono duplicated)

**Key Features**:
- Blocking write to FIFO (autopull enabled)
- Clock generated by PIO for perfect I2S timing
- Simple interface: just push 32-bit value to FIFO

### 1.2 Create `doth/i2s_audio.h`

C++ wrapper for PIO I2S output:

```cpp
class I2SAudio {
private:
    PIO pio;
    uint sm;
    uint offset;
    
public:
    // Initialize PIO state machine
    void Init(uint sample_rate, PIO pio_instance, uint state_machine);
    
    // Convert 8-bit sample to 16-bit and output to both channels
    void WriteSample(uint8_t sample_8bit);
    
    // Check if FIFO has space (blocking not needed in interrupt)
    inline bool CanWrite() {
        return !pio_sm_is_tx_fifo_full(pio, sm);
    }
    
    // Start/stop (enable/disable state machine)
    void Start();
    void Stop();
    
    // Output silence (centered at 0x0000)
    void WriteSilence();
};
```

**8-bit to 16-bit Conversion**:
```cpp
void I2SAudio::WriteSample(uint8_t sample_8bit) {
    // Convert 8-bit unsigned (0-255, 128=silence) to 16-bit signed
    int16_t sample_16bit = ((int16_t)sample_8bit - 128) << 8;
    // 0 → -32768 (negative peak)
    // 128 → 0 (silence)
    // 255 → +32512 (positive peak)
    
    // Duplicate mono to stereo (L and R same)
    uint32_t i2s_data = ((uint32_t)sample_16bit << 16) | (uint32_t)sample_16bit;
    
    // Write to PIO FIFO (non-blocking, we check CanWrite first)
    pio_sm_put(pio, sm, i2s_data);
}
```

---

## Phase 2: Modify Interrupt Handler

### 2.1 Changes in `main.cpp`

#### Rename Handler Function
**Current** (line 280):
```cpp
void pwm_interrupt_handler() {
```

**New**:
```cpp
void audio_interrupt_handler() {
```

#### Change Output Call
**Current** (line 803):
```cpp
pwm_set_gpio_level(AUDIO_PIN, audio_now);
```

**New**:
```cpp
if (i2s_audio.CanWrite()) {
    i2s_audio.WriteSample(audio_now);
}
```

#### Handle Muting
**Current** (line 284):
```cpp
pwm_set_gpio_level(AUDIO_PIN, 128);
```

**New**:
```cpp
i2s_audio.WriteSilence();
```

**Important**: All the audio processing logic between lines 280-803 remains completely untouched:
- Beat counting
- Phase management
- Sample retrieval
- Effects processing
- Filter application
- Volume/distortion
Everything stays the same!

---

## Phase 3: Replace Timing Source

### 3.1 Remove PWM Interrupt Setup

**File**: `main.cpp` lines 982-1003

**Remove**:
```cpp
gpio_set_function(AUDIO_PIN, GPIO_FUNC_PWM);
int audio_pin_slice = pwm_gpio_to_slice_num(AUDIO_PIN);
pwm_clear_irq(audio_pin_slice);
pwm_set_irq_enabled(audio_pin_slice, true);
irq_set_exclusive_handler(PWM_IRQ_WRAP, pwm_interrupt_handler);
irq_set_enabled(PWM_IRQ_WRAP, true);
pwm_config config = pwm_get_default_config();
pwm_config_set_clkdiv(&config, 1.0f);
pwm_config_set_wrap(&config, 250);
pwm_init(audio_pin_slice, &config, true);
pwm_set_gpio_level(AUDIO_PIN, 0);
```

### 3.2 Add Timer Interrupt Setup

**Add** (after line 984):
```cpp
// Initialize I2S audio output
// Use pio1 (pio0 is used by WS2812 if enabled)
i2s_audio.Init(SAMPLE_RATE, pio1, 0);
i2s_audio.Start();

// Setup hardware timer for sample rate interrupt
// Using negative period for precise timing
struct repeating_timer audio_timer;
bool timer_ok = add_repeating_timer_us(
    -(1000000 / SAMPLE_RATE),  // Negative = precise timing
    audio_timer_callback,
    NULL,
    &audio_timer
);
if (!timer_ok) {
    // Handle error
}
```

**Timer Callback** (add before main()):
```cpp
bool audio_timer_callback(struct repeating_timer *t) {
    audio_interrupt_handler();
    return true;  // Keep repeating
}
```

### 3.3 Global I2S Instance

**Add** (around line 90 with other globals):
```cpp
I2SAudio i2s_audio;
```

---

## Phase 4: Update Headers and Build System

### 4.1 Update `main.cpp` Includes

**Remove** (line 12):
```cpp
#include "hardware/pwm.h"    // pwm
```

**Add** (after includes):
```cpp
#include "hardware/pio.h"
#include "pico/time.h"    // for repeating_timer
#include "doth/i2s_audio.h"
```

### 4.2 Update GPIO Defines

**Replace** (line 44):
```cpp
#define AUDIO_PIN 20   // audio out
```

**With**:
```cpp
// I2S Audio Output GPIOs
#define I2S_DATA_PIN 19   // DIN
#define I2S_BCK_PIN 18    // Bit clock
#define I2S_LCK_PIN 20    // Word select (LRCLK)
```

### 4.3 Update `CMakeLists.txt`

**Add** (around line 21):
```cmake
pico_generate_pio_header(${PROJECT_NAME} ${CMAKE_CURRENT_LIST_DIR}/doth/i2s_audio.pio)
```

**Verify** these are already present:
```cmake
target_link_libraries(${PROJECT_NAME} 
    pico_stdlib
    hardware_pio      # ✓ Already present
    hardware_timer    # ✓ Already present
```

**Remove** from `target_link_libraries` (if CPU usage is a concern):
```cmake
    hardware_pwm      # No longer needed
```

---

## Phase 5: Compile-Time Toggle (Optional Safety)

### 5.1 Add Feature Flag

**File**: `target_compile_definitions.cmake`

**Add**:
```cmake
target_compile_definitions(${PROJECT_NAME} PRIVATE
    I2S_AUDIO_ENABLED=1
    # ... existing flags ...
)
```

### 5.2 Conditional Compilation

Wrap new code with:
```cpp
#if I2S_AUDIO_ENABLED == 1
    // I2S code
#else
    // PWM code (legacy)
#endif
```

This allows quick rollback during testing.

---

## Phase 6: Testing Strategy

### 6.1 Compilation Tests
1. ✅ Compile with `I2S_AUDIO_ENABLED=0` (should work as before)
2. ✅ Compile with `I2S_AUDIO_ENABLED=1` (new I2S code)
3. ✅ Verify binary size similar to before

### 6.2 Hardware Tests
1. **Silence test**: Verify silence when `do_mute = true`
2. **DC offset**: Verify centered at 0V (no DC offset)
3. **Full scale**: Play loud sample, measure peak-to-peak voltage
4. **Beat sync**: Verify beats align with control loop timing
5. **Frequency response**: Play test tones, verify no artifacts
6. **CPU usage**: Monitor for increased interrupt overhead

### 6.3 Signal Verification with Oscilloscope
- **BCK**: Verify 992kHz clock (32 × 31kHz)
- **LCK**: Verify 31kHz word select
- **DIN**: Verify data transitions sync with BCK
- **Analog out**: Verify clean audio on PCM5102 output

---

## Implementation Checklist

### Step 1: PIO Development ✅ COMPLETE
- [x] Create `doth/i2s_audio.pio` with I2S protocol
- [x] Create `doth/i2s_audio.h` with C++ wrapper
- [x] Create `doth/i2s_audio.cpp` with implementation
- [x] Test PIO compilation with `pico_generate_pio_header`
- [x] Update CMakeLists.txt with source and PIO header

### Step 2: Integration Preparation ✅ COMPLETE
- [x] Add `I2S_AUDIO_ENABLED=0` to compile definitions
- [x] Add `#if I2S_AUDIO_ENABLED` blocks in main.cpp
- [x] Verify compilation still works with flag=0
- [x] Verify compilation works with flag=1

### Step 3: Core Changes ✅ COMPLETE
- [x] Rename `pwm_interrupt_handler` → `audio_interrupt_handler` (conditional)
- [x] Add `audio_timer_callback` function
- [x] Replace `pwm_set_gpio_level` with `i2s_audio.WriteSample` (conditional)
- [x] Update includes (remove pwm.h, add pio.h, time.h, i2s_audio.h)
- [x] Update GPIO defines (conditional)

### Step 4: Initialization Changes ✅ COMPLETE
- [x] Remove PWM init code (conditional)
- [x] Add I2S init code (conditional)
- [x] Add timer setup code
- [x] Add global `i2s_audio` instance

### Step 5: Build System ✅ COMPLETE
- [x] Update CMakeLists.txt with PIO header generation
- [x] Verify all libraries linked
- [x] Successful compilation (Flash: 366KB, RAM: 9.8KB)

### Step 6: Testing
- [ ] Enable `I2S_AUDIO_ENABLED=1`
- [ ] Compile and check for errors
- [ ] Flash to hardware
- [ ] Test basic playback
- [ ] Test all features (effects, sequencer, sync, etc.)
- [ ] Measure signal quality

### Step 7: Cleanup
- [ ] Remove `#if I2S_AUDIO_ENABLED` conditional blocks
- [ ] Remove all PWM-related code
- [ ] Update comments and documentation
- [ ] Update `architecture.md`
- [ ] Remove `hardware_pwm` from CMakeLists if unused elsewhere

---

## Technical Details

### I2S Timing Calculations

**Sample Rate**: 31,000 Hz  
**Bit Depth**: 16-bit  
**Channels**: 2 (stereo, mono duplicated)  
**Bits per sample**: 32 (16L + 16R)  

**Bit Clock (BCK) Frequency**:
```
BCK = Sample_Rate × Bits_per_Sample
    = 31,000 × 32
    = 992,000 Hz (992 kHz)
```

**Word Select (LCK) Frequency**:
```
LCK = Sample_Rate
    = 31,000 Hz
```

**PIO Clock Divider** (assuming 248 MHz system clock):
```
Divider = System_Clock / BCK
        = 248,000,000 / 992,000
        = 250
```

### Memory Requirements

**No DMA buffers needed** - interrupt writes directly to PIO FIFO  
**PIO FIFO**: 4 entries × 32 bits = 16 bytes per state machine  
**Code size**: ~50 bytes for PIO program  
**Overhead**: Minimal, similar to current PWM approach

### CPU Load Analysis

**Current PWM**: ~31,000 interrupts/sec  
**New Timer**: ~31,000 interrupts/sec  
**Delta**: Negligible (same interrupt rate)

**Advantage**: PIO handles I2S protocol in hardware, no CPU cycles for bit manipulation

---

## Risk Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| Timing jitter | Audio artifacts | Use hardware timer with negative period |
| FIFO overflow | Sample loss | Check `CanWrite()` before write |
| FIFO underflow | Silence gaps | Ensure interrupt rate matches sample rate |
| PIO resource conflict | Build failure | Use pio1 (pio0 used by WS2812) |
| Clock accuracy | Pitch shift | Use precise PIO clock divider calculation |
| Init order dependency | No audio | Init I2S before starting timer |

---

## Rollback Plan

If issues arise:
1. Set `I2S_AUDIO_ENABLED=0` in compile definitions
2. Rebuild and flash
3. System reverts to PWM audio
4. Debug I2S implementation offline

---

## Benefits Summary

✅ **True 16-bit audio output** (vs 8-bit PWM)  
✅ **Lower noise floor** (DAC vs PWM filtering)  
✅ **No external filtering required**  
✅ **Same CPU overhead** (interrupt rate unchanged)  
✅ **Non-invasive** (audio processing untouched)  
✅ **Professional audio quality**  
✅ **Clean DC-coupled output**  
✅ **Easy to test** (compile-time toggle)  

---

## Future Enhancements (Out of Scope)

- [ ] Add DMA for lower CPU usage (if needed)
- [ ] Expand to true stereo processing
- [ ] Increase internal resolution to 16-bit
- [ ] Add I2S input for audio sampling
- [ ] Support higher sample rates (44.1kHz, 48kHz)

---

## References

- [Pico SDK PIO Examples](https://github.com/raspberrypi/pico-examples/tree/master/pio)
- [PCM5102 Datasheet](https://www.ti.com/product/PCM5102)
- [I2S Protocol Specification](https://www.sparkfun.com/datasheets/BreakoutBoards/I2SBUS.pdf)
- [RP2040 Datasheet - PIO Section](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf)

---

## Next Actions

1. **Review this plan** - ensure all stakeholders agree
2. **Create development branch** - `git checkout -b feature/i2s-audio`
3. **Implement Phase 1** - PIO module development
4. **Test incrementally** - verify each phase before moving on
5. **Document changes** - update architecture.md when complete

---

*Last updated: 2026-02-19*  
*Status: Phases 1-4 Complete - Ready for Hardware Testing*

**Build Statistics:**
- PWM Mode (flag=0): Flash 366KB, RAM 9.8KB ✅
- I2S Mode (flag=1): Flash 368KB, RAM 9.9KB ✅
- Size increase: +1.5KB flash, +40 bytes RAM

# Reference implementation

```
; PIO program for I2S audio output
; Outputs 16-bit stereo audio (mono duplicated to both channels)
; Data format: Left channel, Right channel (both same for mono)
;
; GPIO connections:
; - BCK (bit clock): I2S_CLOCK_PIN_BASE
; - DIN (data): I2S_DATA_PIN  
; - LCK/LRCLK (word select): I2S_CLOCK_PIN_BASE + 2

.program i2s_out
.side_set 2

; Each sample is 16 bits, output twice (left and right)
; Side-set controls BCK (bit 0) and LCK (bit 1)

.wrap_target
    ; Left channel (16 bits) - LCK low
    set x, 14           side 0b00    ; 15 more bits to send, LCK=0, BCK=0
left_loop:
    out pins, 1         side 0b01    ; output bit, BCK=1
    jmp x-- left_loop   side 0b00    ; BCK=0
    out pins, 1         side 0b01    ; output final bit, BCK=1
    
    ; Right channel (16 bits) - LCK high
    set x, 14           side 0b10    ; 15 more bits to send, LCK=1, BCK=0
right_loop:
    out pins, 1         side 0b11    ; output bit, BCK=1
    jmp x-- right_loop  side 0b10    ; BCK=0
    out pins, 1         side 0b11    ; output final bit, BCK=1
.wrap

% c-sdk {
static inline void i2s_out_program_init(PIO pio, uint sm, uint offset, uint data_pin, uint clock_pin_base) {
    // Configure data pin as output
    pio_gpio_init(pio, data_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, data_pin, 1, true);
    
    // Configure clock pins (BCK and LCK) as side-set outputs
    pio_gpio_init(pio, clock_pin_base);     // BCK
    pio_gpio_init(pio, clock_pin_base + 2); // LCK (LRCLK)
    pio_sm_set_consecutive_pindirs(pio, sm, clock_pin_base, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, clock_pin_base + 2, 1, true);
    
    // Configure state machine
    pio_sm_config c = i2s_out_program_get_default_config(offset);
    
    // Set data output pin
    sm_config_set_out_pins(&c, data_pin, 1);
    
    // Set side-set pins (BCK and LCK)
    sm_config_set_sideset_pins(&c, clock_pin_base);
    
    // Configure autopull: pull from TX FIFO every 32 bits (16-bit stereo pair)
    sm_config_set_out_shift(&c, false, true, 32);
    
    // Set clock divider for desired sample rate
    // System clock / (2 cycles per bit * 32 bits per sample) = sample rate
    // For 33 kHz: 125 MHz / (2 * 32 * 33000) = ~59.5
    float div = (float)clock_get_hz(clk_sys) / (2.0f * 32.0f * 33000.0f);
    sm_config_set_clkdiv(&c, div);
    
    // Initialize and start state machine
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
```

```
; PIO program for I2S audio output
; Outputs 16-bit stereo audio (mono duplicated to both channels)
; Uses SET pins for LCK and side-set for BCK to avoid consecutive pin requirement
;
; GPIO connections:
; - BCK (bit clock): GPIO 18 (side-set)
; - DIN (data): GPIO 19 (OUT pins)
; - LCK/LRCLK (word select): GPIO 20 (SET pins)

.program i2s_out
.side_set 1

; Standard I2S format: data changes on falling edge of BCK
; LRCLK (LCK) changes one BCK cycle before data starts

.wrap_target
    ; Left channel (16 bits) - LCK low
    set pins, 0         side 0       ; LCK=0 (left channel), BCK=0
    out pins, 1         side 0       ; Setup first bit
    set x, 14           side 1       ; BCK=1, prepare for 15 more bits
bitloop_left:
    out pins, 1         side 0       ; Output bit on BCK falling edge
    jmp x-- bitloop_left side 1      ; BCK=1, continue loop
    
    ; Right channel (16 bits) - LCK high
    set pins, 1         side 0       ; LCK=1 (right channel), BCK=0
    out pins, 1         side 0       ; Setup first bit
    set x, 14           side 1       ; BCK=1, prepare for 15 more bits
bitloop_right:
    out pins, 1         side 0       ; Output bit on BCK falling edge
    jmp x-- bitloop_right side 1     ; BCK=1, continue loop
.wrap

% c-sdk {
static inline void i2s_out_program_init(PIO pio, uint sm, uint offset, uint data_pin, uint clock_pin_base) {
    // data_pin: GPIO 19 (DIN)
    // clock_pin_base: GPIO 18 (BCK will be on side-set)
    // LCK will be GPIO 20 (set via SET pins)
    
    // Configure data pin (GPIO 19) as output
    pio_gpio_init(pio, data_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, data_pin, 1, true);
    
    // Configure BCK (GPIO 18) as side-set output
    pio_gpio_init(pio, clock_pin_base);
    pio_sm_set_consecutive_pindirs(pio, sm, clock_pin_base, 1, true);
    
    // Configure LCK (GPIO 20) as SET pins output
    pio_gpio_init(pio, clock_pin_base + 2);  // GPIO 20
    pio_sm_set_consecutive_pindirs(pio, sm, clock_pin_base + 2, 1, true);
    
    // Configure state machine
    pio_sm_config c = i2s_out_program_get_default_config(offset);
    
    // Set data output pin (GPIO 19)
    sm_config_set_out_pins(&c, data_pin, 1);
    
    // Set side-set pin (GPIO 18 for BCK)
    sm_config_set_sideset_pins(&c, clock_pin_base);
    
    // Set SET pins (GPIO 20 for LCK)
    sm_config_set_set_pins(&c, clock_pin_base + 2, 1);
    
    // Configure autopull: pull from TX FIFO every 32 bits (16-bit stereo pair)
    sm_config_set_out_shift(&c, false, true, 32);
    
    // Set clock divider for desired sample rate  
    // Left channel: 3 setup cycles + 15*2 bit cycles = 33 cycles
    // Right channel: 3 setup cycles + 15*2 bit cycles = 33 cycles
    // Total: 66 PIO cycles per sample
    // For 33 kHz: sys_clock / (66 * 33000) = divider
    float div = (float)clock_get_hz(clk_sys) / (66.0f * 33000.0f);
    sm_config_set_clkdiv(&c, div);
    
    // Initialize and start state machine
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
```